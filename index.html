<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pharmacy Consultation Training - AI Patient Simulator with Avatar</title>
    
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Add proper GLTFLoader -->
    <script>
        // Implement a basic GLTFLoader for Ready Player Me avatars
        THREE.GLTFLoader = function(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.dracoLoader = null;
        };
        
        THREE.GLTFLoader.prototype = {
            constructor: THREE.GLTFLoader,
            
            load: function(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(scope.manager);
                loader.setPath(scope.path);
                loader.setResponseType('arraybuffer');
                loader.load(url, function(data) {
                    try {
                        scope.parse(data, '', onLoad, onError);
                    } catch (e) {
                        if (onError) {
                            onError(e);
                        } else {
                            console.error(e);
                        }
                        scope.manager.itemError(url);
                    }
                }, onProgress, onError);
            },
            
            setPath: function(value) {
                this.path = value;
                return this;
            },
            
            parse: function(data, path, onLoad, onError) {
                const scope = this;
                let json;
                
                const magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
                
                if (magic === 'glTF') {
                    // Binary .glb format
                    const extensions = {
                        KHR_BINARY_GLTF: 'KHR_binary_glTF'
                    };
                    
                    try {
                        json = scope.parseGLB(data);
                    } catch (e) {
                        if (onError) onError(e);
                        return;
                    }
                } else {
                    // Text .gltf format
                    const content = THREE.LoaderUtils.decodeText(new Uint8Array(data));
                    try {
                        json = JSON.parse(content);
                    } catch (e) {
                        if (onError) onError(e);
                        return;
                    }
                }
                
                if (json.asset === undefined || json.asset.version[0] < 2) {
                    if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
                    return;
                }
                
                const parser = new GLTFParser(json, {
                    path: path || scope.resourcePath || '',
                    manager: scope.manager
                });
                
                parser.parse(onLoad, onError);
            },
            
            parseGLB: function(data) {
                const headerView = new DataView(data, 0, 12);
                const header = {
                    magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
                    version: headerView.getUint32(4, true),
                    length: headerView.getUint32(8, true)
                };
                
                if (header.magic !== 'glTF') {
                    throw new Error('THREE.GLTFLoader: Invalid glTF magic.');
                }
                
                const chunkView = new DataView(data, 12);
                let chunkIndex = 0;
                
                const json = {};
                
                while (chunkIndex < chunkView.byteLength) {
                    const chunkLength = chunkView.getUint32(chunkIndex, true);
                    chunkIndex += 4;
                    
                    const chunkType = chunkView.getUint32(chunkIndex, true);
                    chunkIndex += 4;
                    
                    if (chunkType === 0x4E4F534A) { // JSON
                        const contentArray = new Uint8Array(data, 12 + chunkIndex, chunkLength);
                        const content = THREE.LoaderUtils.decodeText(contentArray);
                        Object.assign(json, JSON.parse(content));
                    }
                    
                    chunkIndex += chunkLength;
                }
                
                return json;
            }
        };
        
        // Simplified GLTF Parser for basic avatar loading
        function GLTFParser(json, options) {
            this.json = json || {};
            this.options = options || {};
            this.cache = new Map();
        }
        
        GLTFParser.prototype = {
            parse: function(onLoad, onError) {
                const scope = this;
                const json = this.json;
                
                Promise.resolve().then(function() {
                    return scope.loadScene();
                }).then(function(scene) {
                    onLoad({
                        scene: scene,
                        scenes: [scene],
                        animations: [],
                        cameras: [],
                        asset: json.asset
                    });
                }).catch(onError);
            },
            
            loadScene: function() {
                const json = this.json;
                const scene = new THREE.Group();
                
                if (json.nodes) {
                    for (let i = 0; i < json.nodes.length; i++) {
                        const node = this.loadNode(i);
                        if (node) {
                            scene.add(node);
                        }
                    }
                }
                
                return Promise.resolve(scene);
            },
            
            loadNode: function(nodeIndex) {
                const json = this.json;
                const nodeDef = json.nodes[nodeIndex];
                
                if (!nodeDef) return null;
                
                const node = new THREE.Group();
                
                if (nodeDef.name) node.name = nodeDef.name;
                
                if (nodeDef.translation) {
                    node.position.fromArray(nodeDef.translation);
                }
                
                if (nodeDef.rotation) {
                    node.quaternion.fromArray(nodeDef.rotation);
                }
                
                if (nodeDef.scale) {
                    node.scale.fromArray(nodeDef.scale);
                }
                
                if (nodeDef.mesh !== undefined) {
                    const mesh = this.loadMesh(nodeDef.mesh);
                    if (mesh) {
                        node.add(mesh);
                    }
                }
                
                if (nodeDef.children) {
                    for (let i = 0; i < nodeDef.children.length; i++) {
                        const child = this.loadNode(nodeDef.children[i]);
                        if (child) {
                            node.add(child);
                        }
                    }
                }
                
                return node;
            },
            
            loadMesh: function(meshIndex) {
                const json = this.json;
                const meshDef = json.meshes[meshIndex];
                
                if (!meshDef) return null;
                
                const group = new THREE.Group();
                
                if (meshDef.primitives) {
                    for (let i = 0; i < meshDef.primitives.length; i++) {
                        const primitive = this.loadPrimitive(meshDef.primitives[i]);
                        if (primitive) {
                            group.add(primitive);
                        }
                    }
                }
                
                return group;
            },
            
            loadPrimitive: function(primitiveDef) {
                // Create a basic mesh - this is a simplified implementation
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0xcccccc });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add morph target support
                if (primitiveDef.targets) {
                    mesh.morphTargetInfluences = [];
                    mesh.morphTargetDictionary = {};
                    
                    for (let i = 0; i < primitiveDef.targets.length; i++) {
                        mesh.morphTargetInfluences.push(0);
                        mesh.morphTargetDictionary[`target_${i}`] = i;
                    }
                }
                
                return mesh;
            }
        };
    </script>
    
    <!-- Modern styling for the interface -->
    <style>
        /* Reset default browser styles and set custom properties for colors */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* CSS Variables for easy color scheme changes */
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary-color: #10b981;
            --danger-color: #ef4444;
            --background: #1e3a8a;
            --card-background: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --success-color: #059669;
        }
        
        /* Main body styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Container for centering content */
        .container {
            max-width: 95%;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Header section styling */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        /* Improved instructions styling for better centering */
        .instructions-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            text-align: left;
            max-width: 1500px;
            margin: 0 auto;
        }
        
        .instructions-column {
            flex: 1;
            min-width: 300px;
        }
        
        .instructions-column ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .instructions-column li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        /* Grid layout for main content - MODIFIED FOR 4 COLUMNS WITH AVATAR */
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        /* Card component for sections */
        .card {
            background: var(--card-background);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .card h2 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 1.25rem;
        }
        
        /* Avatar container styling */
        .avatar-container {
            position: relative;
            width: 100%;
            height: 400px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        #avatarCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .avatar-controls {
            margin-top: 15px;
        }
        
        .avatar-status {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .avatar-status.speaking {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }
        
        .avatar-status.idle {
            background-color: #f3f4f6;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        /* Form input styling */
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* Button styling */
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-hover);
        }
        
        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .btn-success:hover {
            background-color: #047857;
        }
        
        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #dc2626;
        }
        
        /* New button style for export */
        .btn-info {
            background-color: #0ea5e9;
            color: white;
        }
        
        .btn-info:hover {
            background-color: #0284c7;
        }
        
        /* Push to talk button special styling */
        .talk-button {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            font-size: 18px;
            margin: 20px auto;
            display: block;
            position: relative;
            overflow: hidden;
        }
        
        .talk-button.recording {
            animation: pulse 1.5s infinite;
            background-color: var(--danger-color);
        }
        
        /* Animation for recording state */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(239, 68, 68, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }
        
        /* Chat display area */
        .chat-container {
            height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            background-color: #fafafa;
        }
        
        /* Individual message styling */
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 8px;
            max-width: 80%;
        }
        
        .message.user {
            background-color: var(--primary-color);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .message.ai {
            background-color: #e5e7eb;
            color: var(--text-primary);
        }
        
        .message.system {
            background-color: #f3f4f6;
            color: var(--text-secondary);
            font-style: italic;
            border-left: 4px solid var(--success-color);
            max-width: 100%;
        }
        
        /* Status indicator */
        .status {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .status.success {
            background-color: #d1fae5;
            color: #065f46;
        }
        
        .status.error {
            background-color: #fee2e2;
            color: #991b1b;
        }
        
        .status.info {
            background-color: #dbeafe;
            color: #1e40af;
        }
        
        /* Loading spinner */
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Button group styling for control buttons */
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        
        .button-group button {
            flex: 1;
            min-width: 140px;
        }
        
        /* Responsive design for mobile devices */
        @media (max-width: 1400px) {
            .grid {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
            }
            
            .card:nth-child(3), .card:nth-child(4) {
                grid-column: 1 / -1;
            }
            
            .instructions-container {
                flex-direction: column;
                gap: 15px;
            }
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .talk-button {
                width: 120px;
                height: 120px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button-group button {
                min-width: auto;
            }
            
            .instructions-container {
                gap: 10px;
            }
            
            .instructions-column {
                min-width: auto;
            }
            
            .avatar-container {
                height: 300px;
            }
        }
        
        /* Audio visualizer */
        .audio-visualizer {
            width: 100%;
            height: 60px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .visualizer-bar {
            width: 4px;
            background: var(--primary-color);
            margin: 0 1px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header section with title and description -->
        <div class="header">
            <h1>🤖 Pharmacy Consultation Training</h1>
            <p>Practice your consultation skills with an AI-powered patient simulator featuring realistic avatar interaction</p>
        </div>
        
        <!-- Instructions box -->
        <div class="header">
            <h2>📋 Instructions</h2>
            <div class="instructions-container">
                <div class="instructions-column">
                    <ol>
                        <li>Enter your n8n webhook URLs in the Configuration section</li>
                        <li>Load your Google Sheet with patient scenarios</li>
                        <li>Select a patient scenario from the dropdown (or choose random)</li>
                    </ol>
                </div>
                <div class="instructions-column" style="flex: 1;">
                    <ol start="4">
                        <li>Choose your avatar and adjust voice settings</li>
                        <li>Hold down the "Push to Talk" button and speak your consultation</li>
                        <li>Watch the AI patient avatar respond with realistic lip sync and expressions</li>
                    </ol>
                </div>
                <div class="instructions-column" style="flex: 1;">
                    <ol start="7">
                        <li>Use "Submit Conversation" to get evaluation feedback</li>
                        <li>Use "Export Feedback" to download your session</li>
                        <li>IMPORTANT - refresh the browser after each scenario to generate a new session id</li>
                    </ol>
                </div>
            </div>
            <p><strong>Tips:</strong> Speak clearly, ask open-ended questions, and observe the avatar's non-verbal cues!</p>
        </div>
        
        <!-- Status display area for system messages -->
        <div id="status" class="status info" style="display: none;"></div>
        
        <!-- Main content grid -->
        <div class="grid">
            <!-- Configuration section -->
            <div class="card">
                <h2>⚙️ Configuration</h2>
                
                <!-- n8n webhook URL input -->
                <div class="form-group">
                    <label for="webhookUrl">n8n Webhook URL (Chat):</label>
                    <input 
                        type="url" 
                        id="webhookUrl" 
                        placeholder="https://your-n8n-instance.com/webhook/..."
                        title="Enter your n8n webhook URL that will receive the messages"
                    >
                </div>
                
                <!-- Submit webhook URL input -->
                <div class="form-group">
                    <label for="submitWebhookUrl">n8n Submit Webhook URL:</label>
                    <input 
                        type="url" 
                        id="submitWebhookUrl" 
                        placeholder="https://your-n8n-instance.com/webhook/submit..."
                        title="Enter your n8n webhook URL for submitting conversation history"
                    >
                </div>
                
                <!-- Google Sheets configuration -->
                <div class="form-group">
                    <label for="sheetId">Google Sheet ID:</label>
                    <input 
                        type="text" 
                        id="sheetId" 
                        placeholder="1ABC...xyz"
                        title="The ID from your Google Sheets URL"
                    >
                    <button 
                        class="btn-secondary" 
                        onclick="loadSheetNames()" 
                        style="margin-top: 10px; width: 100%;"
                    >
                        📋 Get Sheet Names
                    </button>
                </div>
                
                <div class="form-group">
                    <label for="sheetName">Sheet Name:</label>
                    <select id="sheetName" disabled>
                        <option value="">Get sheet names first...</option>
                    </select>
                </div>
                
                <!-- Scenario selection dropdown -->
                <div class="form-group" style="margin-top: 20px;">
                    <label for="scenarioSelect">Select Scenario:</label>
                    <select id="scenarioSelect" disabled>
                        <option value="">Load sheet data first...</option>
                    </select>
                </div>
                
                <button class="btn-secondary" onclick="selectRandomScenario()" style="margin-top: 10px;">
                    🎲 Random Scenario
                </button>
            </div>
            
            <!-- Voice control section -->
            <div class="card">
                <h2>🎙️ Voice Control</h2>
                
                <!-- Voice settings -->
                <div class="form-group">
                    <label for="voiceSelect">AI Voice Type:</label>
                    <select id="voiceSelect">
                        <option value="female-young">Young Female</option>
                        <option value="female-adult">Adult Female</option>
                        <option value="male-young">Young Male</option>
                        <option value="male-adult">Adult Male</option>
                        <option value="elderly-female">Elderly Female</option>
                        <option value="elderly-male">Elderly Male</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="speechRate">Speech Rate:</label>
                    <input 
                        type="range" 
                        id="speechRate" 
                        min="0.5" 
                        max="2" 
                        step="0.1" 
                        value="1"
                    >
                    <span id="rateValue">1.0</span>
                </div>
                
                <!-- Live transcription within voice control -->
                <div class="form-group" style="margin-top: 20px;">
                    <label for="transcriptionBox">📝 Live Transcription:</label>
                    <div id="transcriptionBox" style="
                        min-height: 60px;
                        max-height: 120px;
                        overflow-y: auto;
                        padding: 15px;
                        background-color: #f9fafb;
                        border: 1px solid var(--border-color);
                        border-radius: 6px;
                        font-size: 16px;
                        line-height: 1.5;
                    ">
                        <span style="color: var(--text-secondary);">Transcription will appear here when you speak...</span>
                    </div>
                </div>
                
                <!-- Push to talk button -->
                <button 
                    class="talk-button btn-danger" 
                    id="talkButton"
                    onmousedown="startRecording()"
                    onmouseup="stopRecording()"
                    onmouseleave="stopRecording()"
                    ontouchstart="startRecording()"
                    ontouchend="stopRecording()"
                    style="margin-top: 60px;"
                >
                    Push to Talk
                </button>
                
                <p style="text-align: center; color: var(--text-secondary);">
                    Hold down the button to speak
                </p>
            </div>
            
            <!-- Avatar section -->
            <div class="card">
                <h2>👥 AI Patient Avatar</h2>
                
                <!-- Avatar status -->
                <div id="avatarStatus" class="avatar-status idle">
                    Avatar Ready - Select a scenario to begin
                </div>
                
                <!-- Avatar display area -->
                <div class="avatar-container">
                    <canvas id="avatarCanvas"></canvas>
                </div>
                
                <!-- Avatar controls -->
                <div class="avatar-controls">
                    <div class="form-group">
                        <label for="avatarUrlInput">Ready Player Me Avatar URL:</label>
                        <input 
                            type="url" 
                            id="avatarUrlInput" 
                            placeholder="Paste your Ready Player Me .glb URL here"
                            onchange="loadCustomAvatar()"
                            style="margin-bottom: 10px;"
                        >
                        <small style="color: var(--text-secondary); display: block; margin-bottom: 10px;">
                            Create avatars at <a href="https://readyplayer.me/avatar" target="_blank">readyplayer.me</a> and paste the .glb link here
                        </small>
                    </div>
                    
                    <div class="form-group">
                        <label for="avatarSelect">Demo Avatars:</label>
                        <select id="avatarSelect" onchange="changeAvatar()">
                            <option value="simple-female">Simple Female Avatar</option>
                            <option value="simple-male">Simple Male Avatar</option>
                            <option value="simple-young">Simple Young Avatar</option>
                            <option value="simple-elderly">Simple Elderly Avatar</option>
                        </select>
                        <small style="color: var(--text-secondary); display: block; margin-top: 5px;">
                            These are basic demo avatars. Use the URL input above for Ready Player Me avatars.
                        </small>
                    </div>
                    
                    <!-- Avatar Expression Controls -->
                    <div class="form-group">
                        <label>Avatar Expressions:</label>
                        <div style="display: flex; gap: 5px; flex-wrap: wrap; margin-top: 5px;">
                            <button class="btn-secondary" onclick="setAvatarExpression('neutral')" style="padding: 5px 10px; font-size: 12px;">😐 Neutral</button>
                            <button class="btn-secondary" onclick="setAvatarExpression('happy')" style="padding: 5px 10px; font-size: 12px;">😊 Happy</button>
                            <button class="btn-secondary" onclick="setAvatarExpression('sad')" style="padding: 5px 10px; font-size: 12px;">😔 Sad</button>
                            <button class="btn-secondary" onclick="setAvatarExpression('concerned')" style="padding: 5px 10px; font-size: 12px;">😟 Worried</button>
                        </div>
                    </div>
                    
                    <!-- Audio visualizer -->
                    <div class="audio-visualizer" id="audioVisualizer">
                        <div class="visualizer-bar" style="height: 10px;"></div>
                        <div class="visualizer-bar" style="height: 20px;"></div>
                        <div class="visualizer-bar" style="height: 15px;"></div>
                        <div class="visualizer-bar" style="height: 25px;"></div>
                        <div class="visualizer-bar" style="height: 30px;"></div>
                        <div class="visualizer-bar" style="height: 20px;"></div>
                        <div class="visualizer-bar" style="height: 35px;"></div>
                        <div class="visualizer-bar" style="height: 15px;"></div>
                        <div class="visualizer-bar" style="height: 25px;"></div>
                        <div class="visualizer-bar" style="height: 10px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Chat display area -->
            <div class="card">
                <h2>💬 Conversation</h2>
                <div class="chat-container" id="chatContainer">
                    <p style="text-align: center; color: var(--text-secondary);">
                        Select a scenario and start speaking to begin the consultation...
                    </p>
                </div>
                
                <!-- Control buttons with improved layout -->
                <div class="button-group">
                    <button class="btn-secondary" onclick="clearChat()">
                        🔄 Clear Chat
                    </button>
                    <button class="btn-danger" onclick="submitConversation()">
                        📤 Submit Chat
                    </button>
                    <button class="btn-info" onclick="exportConversation()">
                        📥 Export Chat
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- JavaScript code for functionality -->
    <script>
        // ===== GLOBAL VARIABLES =====
        // These store the state of our application
        
        let recognition = null;           // Speech recognition object
        let isRecording = false;          // Track if we're currently recording
        let currentScenario = null;       // Store the selected patient scenario
        let conversationHistory = [];     // Store all messages in the conversation
        let sheetData = [];              // Store data loaded from Google Sheets
        let sessionId = '';              // Unique session identifier for this training session
        let fullTranscript = '';         // Store the complete transcript during recording
        let forceStopRecognition = false; // Flag to force stop recognition
        
        // Avatar and 3D related variables
        let scene, camera, renderer, avatar, mixer;
        let avatarLoaded = false;
        let currentAnimation = null;
        let lipSyncData = null;
        let audioContext = null;
        let analyser = null;
        let isSpeaking = false;
        let currentAvatarUrl = null;
        let avatarMorphTargets = null;
        let visemePlayer = null;
        
        // ===== INITIALIZATION =====
        // This runs when the page loads
        
        window.onload = function() {
            // Generate unique session ID for this training session
            generateSessionId();
            
            // Initialize speech recognition if available
            initializeSpeechRecognition();
            
            // Initialize 3D avatar system
            initializeAvatar();
            
            // Set up event listeners
            setupEventListeners();
            
            // Load saved configuration from localStorage
            loadSavedConfig();
            
            // Display session info
            displaySessionInfo();
        };
        
        // ===== AVATAR SYSTEM =====
        // Initialize Three.js and avatar system
        
        function initializeAvatar() {
            const canvas = document.getElementById('avatarCanvas');
            const container = canvas.parentElement;
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Load default Ready Player Me avatar
            loadAvatarModel();
            
            // Start render loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function loadAvatarModel(avatarIdentifier) {
            updateAvatarStatus('Loading avatar...', 'info');
            
            // Check if it's a URL (Ready Player Me) or a simple avatar type
            if (avatarIdentifier && avatarIdentifier.startsWith('http')) {
                // This is a Ready Player Me URL
                loadReadyPlayerMeAvatar(avatarIdentifier);
            } else {
                // Use simple avatar as fallback/demo
                const avatarType = avatarIdentifier || document.getElementById('avatarSelect').value;
                createSimpleAvatar(avatarType);
                avatarLoaded = true;
                updateAvatarStatus('Demo avatar loaded', 'idle');
            }
        }
        
        function loadReadyPlayerMeAvatar(url) {
            updateAvatarStatus('Loading Ready Player Me avatar...', 'info');
            currentAvatarUrl = url;
            
            // For this demo, we'll use a more robust approach to load GLTF files
            // Since the CDN GLTFLoader might not work, we'll implement a fallback
            
            try {
                // Try to use GLTFLoader if available
                if (typeof THREE.GLTFLoader !== 'undefined') {
                    const loader = new THREE.GLTFLoader();
                    
                    loader.load(
                        url,
                        (gltf) => {
                            setupReadyPlayerMeAvatar(gltf);
                        },
                        (progress) => {
                            const percent = Math.round((progress.loaded / progress.total) * 100);
                            updateAvatarStatus(`Loading avatar: ${percent}%`, 'info');
                        },
                        (error) => {
                            console.error('Error loading Ready Player Me avatar:', error);
                            handleAvatarLoadError();
                        }
                    );
                } else {
                    throw new Error('GLTFLoader not available');
                }
            } catch (error) {
                console.error('GLTFLoader error:', error);
                handleAvatarLoadError();
            }
        }
        
        function handleAvatarLoadError() {
            updateAvatarStatus('Ready Player Me avatar failed - using demo avatar', 'error');
            showStatus('Could not load Ready Player Me avatar. Using demo avatar instead.', 'error');
            
            // Fallback to simple avatar
            createSimpleAvatar('simple-female');
            avatarLoaded = true;
            
            setTimeout(() => {
                updateAvatarStatus('Demo avatar ready', 'idle');
            }, 1000);
        }
        
        function setupReadyPlayerMeAvatar(gltf) {
            // Remove existing avatar
            if (avatar) {
                scene.remove(avatar);
                if (mixer) {
                    mixer.stopAllAction();
                }
            }
            
            // Set up new avatar
            avatar = gltf.scene;
            scene.add(avatar);
            
            // Scale and position avatar
            avatar.scale.setScalar(1);
            avatar.position.set(0, -1.6, 0);
            
            // Set up animation mixer
            mixer = new THREE.AnimationMixer(avatar);
            
            // Find and set up morph targets for lip sync
            setupMorphTargets(avatar);
            
            // Set up default pose
            setupAvatarPose(avatar);
            
            avatarLoaded = true;
            updateAvatarStatus('Ready Player Me avatar loaded successfully!', 'idle');
            
            console.log('Ready Player Me avatar loaded successfully');
        }
        
        function setupMorphTargets(avatarModel) {
            // Find the head mesh with morph targets
            avatarMorphTargets = null;
            
            avatarModel.traverse((child) => {
                if (child.isMesh && child.morphTargetDictionary) {
                    // Check if this mesh has viseme morph targets
                    const morphDict = child.morphTargetDictionary;
                    const visemeKeys = Object.keys(morphDict).filter(key => 
                        key.toLowerCase().includes('viseme') || 
                        key.toLowerCase().includes('jaw') ||
                        key.toLowerCase().includes('mouth')
                    );
                    
                    if (visemeKeys.length > 0) {
                        avatarMorphTargets = child;
                        console.log('Found morph targets:', visemeKeys);
                        
                        // Initialize morph target influences
                        if (child.morphTargetInfluences) {
                            child.morphTargetInfluences.fill(0);
                        }
                        
                        return;
                    }
                }
            });
            
            if (!avatarMorphTargets) {
                console.warn('No morph targets found for lip sync');
            }
        }
        
        function setupAvatarPose(avatarModel) {
            // Set up default pose and materials
            avatarModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Enhance materials
                    if (child.material) {
                        child.material.envMapIntensity = 0.8;
                        child.material.metalness = 0.0;
                        child.material.roughness = 1.0;
                    }
                }
            });
        }
        
        function changeAvatar() {
            const selectedValue = document.getElementById('avatarSelect').value;
            loadAvatarModel(selectedValue);
        }
        
        function loadCustomAvatar() {
            const customUrl = document.getElementById('avatarUrlInput').value.trim();
            
            if (!customUrl) {
                showStatus('Please enter a Ready Player Me avatar URL', 'error');
                return;
            }
            
            if (!customUrl.includes('readyplayer.me') && !customUrl.includes('.glb')) {
                showStatus('Please enter a valid Ready Player Me .glb URL', 'error');
                return;
            }
            
            // Test if URL is accessible
            fetch(customUrl, { method: 'HEAD' })
                .then(response => {
                    if (response.ok) {
                        loadAvatarModel(customUrl);
                        showStatus('Loading your Ready Player Me avatar...', 'info');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                })
                .catch(error => {
                    console.error('Avatar URL test failed:', error);
                    showStatus('Could not access avatar URL. Check if the URL is correct and publicly accessible.', 'error');
                    
                    // Still try to load it in case the HEAD request fails but GET works
                    loadAvatarModel(customUrl);
                });
        }
        
        // Enhanced simple avatar creation with better features
        function createSimpleAvatar(avatarType) {
            // Clear existing avatar
            if (avatar) {
                scene.remove(avatar);
            }
            
            avatar = new THREE.Group();
            
            // Determine avatar characteristics based on type
            let skinColor = 0xffdbac;
            let hairColor = 0x8b4513;
            let clothingColor = 0x4169e1;
            let scale = 1;
            
            switch(avatarType) {
                case 'simple-female':
                    skinColor = 0xffdbac;
                    hairColor = 0x654321;
                    clothingColor = 0xff69b4;
                    break;
                case 'simple-male':
                    skinColor = 0xdeb887;
                    hairColor = 0x2f1b14;
                    clothingColor = 0x4169e1;
                    break;
                case 'simple-young':
                    skinColor = 0xffeaa7;
                    hairColor = 0xfcb900;
                    clothingColor = 0x00b894;
                    scale = 0.9;
                    break;
                case 'simple-elderly':
                    skinColor = 0xf5deb3;
                    hairColor = 0xc0c0c0;
                    clothingColor = 0x8b4513;
                    scale = 0.95;
                    break;
            }
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.userData = { type: 'head' };
            avatar.add(head);
            
            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.52, 16, 16);
            const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.7;
            hair.scale.set(1, 0.8, 1);
            avatar.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 1.6, 0.4);
            avatar.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 1.6, 0.4);
            avatar.add(rightEye);
            
            // Eyebrows
            const browGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.05);
            const browMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
            
            const leftBrow = new THREE.Mesh(browGeometry, browMaterial);
            leftBrow.position.set(-0.15, 1.75, 0.4);
            avatar.add(leftBrow);
            
            const rightBrow = new THREE.Mesh(browGeometry, browMaterial);
            rightBrow.position.set(0.15, 1.75, 0.4);
            avatar.add(rightBrow);
            
            // Mouth (enhanced for better lip sync)
            const mouthGeometry = new THREE.RingGeometry(0.05, 0.12, 8);
            const mouthMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8b0000,
                side: THREE.DoubleSide 
            });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.3, 0.48);
            mouth.userData = { type: 'mouth', baseScale: 1, baseRadius: 0.05 };
            avatar.add(mouth);
            
            // Nose
            const noseGeometry = new THREE.ConeGeometry(0.05, 0.15, 8);
            const noseMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 1.45, 0.45);
            nose.rotation.x = Math.PI / 2;
            avatar.add(nose);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: clothingColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            avatar.add(body);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.6, 0.6, 0);
            leftArm.rotation.z = 0.3;
            avatar.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.6, 0.6, 0);
            rightArm.rotation.z = -0.3;
            avatar.add(rightArm);
            
            // Apply scale
            avatar.scale.setScalar(scale);
            
            scene.add(avatar);
            
            // Add subtle idle animation
            startIdleAnimation();
            
            console.log(`Created simple avatar: ${avatarType}`);
        }
        
        function createSimpleAvatar(avatarType) {
            // Clear existing avatar
            if (avatar) {
                scene.remove(avatar);
            }
            
            avatar = new THREE.Group();
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.userData = { type: 'head' };
            avatar.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 1.6, 0.4);
            avatar.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 1.6, 0.4);
            avatar.add(rightEye);
            
            // Mouth (will be animated for lip sync)
            const mouthGeometry = new THREE.RingGeometry(0.05, 0.1, 8);
            const mouthMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8b0000,
                side: THREE.DoubleSide 
            });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.3, 0.48);
            mouth.userData = { type: 'mouth', baseScale: 1 };
            avatar.add(mouth);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
            let bodyColor = 0x4169e1; // Royal blue for doctor
            
            switch(avatarType) {
                case 'patient-young':
                    bodyColor = 0x32cd32; // Lime green
                    break;
                case 'patient-adult':
                    bodyColor = 0xff6347; // Tomato
                    break;
                case 'patient-elderly':
                    bodyColor = 0x8b4513; // Saddle brown
                    break;
            }
            
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            avatar.add(body);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.6, 0.6, 0);
            leftArm.rotation.z = 0.3;
            avatar.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.6, 0.6, 0);
            rightArm.rotation.z = -0.3;
            avatar.add(rightArm);
            
            scene.add(avatar);
            
            // Add subtle idle animation
            startIdleAnimation();
        }
        
        function startIdleAnimation() {
            if (!avatar) return;
            
            const head = avatar.children.find(child => child.userData.type === 'head');
            if (head) {
                // Subtle head movement
                const idleAnimation = () => {
                    if (head && !isSpeaking) {
                        head.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
                        head.rotation.x = Math.sin(Date.now() * 0.0008) * 0.05;
                    }
                    requestAnimationFrame(idleAnimation);
                };
                idleAnimation();
            }
        }
        
        function animateReadyPlayerMeLipSync(text, speechRate) {
            if (!avatarMorphTargets || !text) return;
            
            // Simple viseme mapping for basic lip sync
            const visemeMap = {
                'sil': ['', ' ', '.', ',', '!', '?'],
                'PP': ['p', 'b', 'm'],
                'FF': ['f', 'v'],
                'TH': ['th'],
                'DD': ['t', 'd', 'n', 'l'],
                'kk': ['k', 'g'],
                'CH': ['ch', 'j', 'sh', 'zh'],
                'SS': ['s', 'z'],
                'nn': ['n', 'ng'],
                'RR': ['r'],
                'aa': ['a', 'ah'],
                'E': ['e', 'eh'],
                'I': ['i', 'ih'],
                'O': ['o', 'oh'],
                'U': ['u', 'uh']
            };
            
            // Convert text to phonemes (simplified)
            const words = text.toLowerCase().split(' ');
            const morphDict = avatarMorphTargets.morphTargetDictionary;
            
            let wordIndex = 0;
            const avgTimePerWord = (60 / (150 * speechRate)) * 1000;
            
            const animateLipSync = () => {
                if (wordIndex >= words.length || !isSpeaking) {
                    // Reset all morph targets
                    if (avatarMorphTargets && avatarMorphTargets.morphTargetInfluences) {
                        avatarMorphTargets.morphTargetInfluences.fill(0);
                    }
                    return;
                }
                
                const word = words[wordIndex];
                
                // Reset previous morph targets
                if (avatarMorphTargets.morphTargetInfluences) {
                    avatarMorphTargets.morphTargetInfluences.fill(0);
                }
                
                // Simple phoneme detection and morph target activation
                for (const [viseme, phonemes] of Object.entries(visemeMap)) {
                    for (const phoneme of phonemes) {
                        if (word.includes(phoneme)) {
                            // Try to find corresponding morph target
                            const possibleTargets = [
                                `viseme_${viseme}`,
                                `Viseme_${viseme}`,
                                viseme.toLowerCase(),
                                viseme.toUpperCase()
                            ];
                            
                            for (const targetName of possibleTargets) {
                                if (morphDict[targetName] !== undefined) {
                                    const targetIndex = morphDict[targetName];
                                    if (avatarMorphTargets.morphTargetInfluences[targetIndex] !== undefined) {
                                        avatarMorphTargets.morphTargetInfluences[targetIndex] = 0.8;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
                
                wordIndex++;
                setTimeout(animateLipSync, avgTimePerWord);
            };
            
            animateLipSync();
        }
        
        function setAvatarExpression(expression) {
            // For Ready Player Me avatars, use morph targets
            if (avatarMorphTargets && avatarMorphTargets.morphTargetDictionary) {
                const morphDict = avatarMorphTargets.morphTargetDictionary;
                const influences = avatarMorphTargets.morphTargetInfluences;
                
                // Reset all expression morph targets
                Object.keys(morphDict).forEach(key => {
                    if (key.toLowerCase().includes('expression') || 
                        key.toLowerCase().includes('smile') ||
                        key.toLowerCase().includes('frown') ||
                        key.toLowerCase().includes('brow')) {
                        const index = morphDict[key];
                        if (influences[index] !== undefined) {
                            influences[index] = 0;
                        }
                    }
                });
                
                // Apply selected expression
                const expressionMappings = {
                    'happy': ['smileLeft', 'smileRight', 'mouthSmile'],
                    'sad': ['frownLeft', 'frownRight', 'mouthFrown'],
                    'concerned': ['browDownLeft', 'browDownRight', 'mouthPress'],
                    'neutral': [] // No additional morphs needed
                };
                
                const targetMorphs = expressionMappings[expression] || [];
                
                targetMorphs.forEach(morphName => {
                    const possibleNames = [
                        morphName,
                        morphName.charAt(0).toUpperCase() + morphName.slice(1),
                        `expression_${morphName}`,
                        `Expression_${morphName}`
                    ];
                    
                    for (const name of possibleNames) {
                        if (morphDict[name] !== undefined) {
                            const index = morphDict[name];
                            if (influences[index] !== undefined) {
                                influences[index] = 0.7;
                                break;
                            }
                        }
                    }
                });
            } else {
                // For simple avatars, use the simple expression system
                adjustSimpleAvatarExpression(expression);
            }
            
            updateAvatarStatus(`Expression set to: ${expression}`, 'idle');
        }Name}`,
                    `Expression_${morphName}`
                ];
                
                for (const name of possibleNames) {
                    if (morphDict[name] !== undefined) {
                        const index = morphDict[name];
                        if (influences[index] !== undefined) {
                            influences[index] = 0.7;
                            break;
                        }
                    }
                }
            });
            
            updateAvatarStatus(`Expression set to: ${expression}`, 'idle');
        }
        
        function updateAvatarStatus(message, type) {
            const statusElement = document.getElementById('avatarStatus');
            statusElement.textContent = message;
            statusElement.className = `avatar-status ${type}`;
        }
        
        function changeAvatar() {
            const avatarType = document.getElementById('avatarSelect').value;
            loadAvatarModel(avatarType);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update mixer for animations
            if (mixer) {
                mixer.update(0.016);
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const canvas = document.getElementById('avatarCanvas');
            const container = canvas.parentElement;
            
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // ===== ENHANCED TEXT TO SPEECH WITH AVATAR =====
        // Replace browser TTS with avatar-based speech
        
        async function speakWithAvatar(text) {
            console.log('Avatar speaking:', text);
            
            if (!avatarLoaded) {
                console.warn('Avatar not loaded, falling back to browser TTS');
                speakTextFallback(text);
                return;
            }
            
            updateAvatarStatus('Speaking...', 'speaking');
            isSpeaking = true;
            
            try {
                // Initialize audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                }
                
                // Use Web Speech API with audio analysis for lip sync
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Set voice based on avatar type
                const voiceType = document.getElementById('voiceSelect').value;
                const voices = speechSynthesis.getVoices();
                
                // Try to match voice to avatar type
                const preferredVoice = voices.find(voice => {
                    if (voiceType.includes('female') && voice.name.toLowerCase().includes('female')) return true;
                    if (voiceType.includes('male') && voice.name.toLowerCase().includes('male')) return true;
                    if (voiceType.includes('young') && voice.name.toLowerCase().includes('zira')) return true;
                    return false;
                }) || voices[0];
                
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }
                
                utterance.rate = parseFloat(document.getElementById('speechRate').value);
                utterance.pitch = voiceType.includes('young') ? 1.2 : 
                                 voiceType.includes('elderly') ? 0.8 : 1.0;
                
                // Start visual feedback
                startAudioVisualization();
                
                // Use Ready Player Me lip sync instead of simple simulation
                if (currentAvatarUrl && currentAvatarUrl.includes('readyplayer.me')) {
                    animateReadyPlayerMeLipSync(text, utterance.rate);
                } else {
                    // Use simple lip sync for demo avatars
                    animateSimpleLipSync(text, utterance.rate);
                }
                
                utterance.onstart = function() {
                    console.log('Avatar speech started');
                };
                
                utterance.onend = function() {
                    console.log('Avatar speech ended');
                    stopAvatarSpeaking();
                };
                
                utterance.onerror = function(event) {
                    console.error('Avatar speech error:', event);
                    stopAvatarSpeaking();
                };
                
                // Speak
                speechSynthesis.speak(utterance);
                
            } catch (error) {
                console.error('Avatar speech error:', error);
                stopAvatarSpeaking();
                speakTextFallback(text);
            }
        }
        
        function simulateLipSync(text, rate) {
            if (!avatar) return;
            
            const words = text.split(' ');
            const avgTimePerWord = (60 / (150 * rate)) * 1000; // Approximate timing
            
            let wordIndex = 0;
            const lipSyncInterval = setInterval(() => {
                if (wordIndex >= words.length || !isSpeaking) {
                    clearInterval(lipSyncInterval);
                    return;
                }
                
                const word = words[wordIndex];
                const vowels = word.match(/[aeiouAEIOU]/g) || [];
                const consonants = word.match(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/g) || [];
                
                // Animate based on phoneme types
                const mouth = avatar.children.find(child => child.userData.type === 'mouth');
                if (mouth) {
                    const openAmount = (vowels.length * 1.5 + consonants.length * 0.8) / word.length;
                    const scale = mouth.userData.baseScale + (openAmount * 1.5);
                    mouth.scale.set(scale, scale, 1);
                    
                    // Reset mouth after short delay
                    setTimeout(() => {
                        if (mouth) {
                            mouth.scale.set(mouth.userData.baseScale, mouth.userData.baseScale, 1);
                        }
                    }, avgTimePerWord * 0.7);
                }
                
                wordIndex++;
            }, avgTimePerWord);
        }
        
        function startAudioVisualization() {
            const visualizer = document.getElementById('audioVisualizer');
            const bars = visualizer.children;
            
            const animateBars = () => {
                if (!isSpeaking) return;
                
                for (let i = 0; i < bars.length; i++) {
                    const height = Math.random() * 40 + 10;
                    bars[i].style.height = height + 'px';
                }
                
                setTimeout(animateBars, 100);
            };
            
            animateBars();
        }
        
        function animateSimpleLipSync(text, speechRate) {
            if (!avatar) return;
            
            const mouth = avatar.children.find(child => child.userData.type === 'mouth');
            if (!mouth) return;
            
            const words = text.split(' ');
            const avgTimePerWord = (60 / (150 * speechRate)) * 1000;
            
            let wordIndex = 0;
            const lipSyncInterval = setInterval(() => {
                if (wordIndex >= words.length || !isSpeaking) {
                    clearInterval(lipSyncInterval);
                    // Reset mouth
                    if (mouth) {
                        mouth.scale.set(mouth.userData.baseScale, mouth.userData.baseScale, 1);
                    }
                    return;
                }
                
                const word = words[wordIndex];
                const vowels = word.match(/[aeiouAEIOU]/g) || [];
                const consonants = word.match(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/g) || [];
                
                // Animate based on phoneme types
                if (mouth) {
                    const openAmount = (vowels.length * 1.5 + consonants.length * 0.8) / Math.max(word.length, 1);
                    const scale = mouth.userData.baseScale + (openAmount * 1.5);
                    mouth.scale.set(scale, scale, 1);
                    
                    // Reset mouth after short delay
                    setTimeout(() => {
                        if (mouth && isSpeaking) {
                            mouth.scale.set(mouth.userData.baseScale, mouth.userData.baseScale, 1);
                        }
                    }, avgTimePerWord * 0.7);
                }
                
                wordIndex++;
            }, avgTimePerWord);
        }
        
        function stopAvatarSpeaking() {
            isSpeaking = false;
            updateAvatarStatus('Avatar ready', 'idle');
            
            if (currentAvatarUrl && currentAvatarUrl.includes('readyplayer.me')) {
                // Reset Ready Player Me morph targets
                if (avatarMorphTargets && avatarMorphTargets.morphTargetInfluences) {
                    const morphDict = avatarMorphTargets.morphTargetDictionary;
                    Object.keys(morphDict).forEach(key => {
                        if (key.toLowerCase().includes('viseme')) {
                            const index = morphDict[key];
                            if (avatarMorphTargets.morphTargetInfluences[index] !== undefined) {
                                avatarMorphTargets.morphTargetInfluences[index] = 0;
                            }
                        }
                    });
                }
            } else {
                // Reset simple avatar mouth
                if (avatar) {
                    const mouth = avatar.children.find(child => child.userData.type === 'mouth');
                    if (mouth) {
                        mouth.scale.set(mouth.userData.baseScale, mouth.userData.baseScale, 1);
                    }
                }
            }
            
            // Reset visualizer
            const visualizer = document.getElementById('audioVisualizer');
            const bars = visualizer.children;
            for (let i = 0; i < bars.length; i++) {
                bars[i].style.height = '10px';
            }
        }
        
        // Fallback to browser TTS if avatar fails
        function speakTextFallback(text) {
            console.log('Using fallback TTS:', text);
            
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            const voices = speechSynthesis.getVoices();
            
            if (voices.length > 0) {
                utterance.voice = voices[0];
            }
            
            utterance.rate = parseFloat(document.getElementById('speechRate').value);
            speechSynthesis.speak(utterance);
        }
        
        // ===== SESSION MANAGEMENT =====
        // Generate and manage unique session IDs
        
        function generateSessionId() {
            const timestamp = Date.now();
            const randomStr = Math.random().toString(36).substring(2, 15);
            sessionId = `session_${timestamp}_${randomStr}`;
            console.log('New session started:', sessionId);
        }
        
        function displaySessionInfo() {
            const header = document.querySelector('.header');
            const sessionInfo = document.createElement('p');
            sessionInfo.style.fontSize = '0.9em';
            sessionInfo.style.color = 'var(--text-secondary)';
            sessionInfo.style.marginTop = '10px';
            sessionInfo.innerHTML = `Session ID: <code style="background: #f3f4f6; padding: 2px 6px; border-radius: 4px;">${sessionId}</code>`;
            header.appendChild(sessionInfo);
        }
        
        // ===== SPEECH RECOGNITION SETUP =====
        
        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                
                recognition.onresult = function(event) {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    if (finalTranscript) {
                        fullTranscript += finalTranscript;
                    }
                    
                    const transcriptionBox = document.getElementById('transcriptionBox');
                    let displayText = '';
                    
                    if (fullTranscript) {
                        displayText += `<span style="color: black;">${fullTranscript.trim()}</span>`;
                    }
                    
                    if (interimTranscript) {
                        if (fullTranscript) {
                            displayText += ' ';
                        }
                        displayText += `<span style="color: #6b7280; font-style: italic;">${interimTranscript}</span>`;
                    }
                    
                    transcriptionBox.innerHTML = displayText || '<span style="color: var(--text-secondary);">Listening...</span>';
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    if (event.error !== 'aborted') {
                        showStatus('Speech recognition error: ' + event.error, 'error');
                    }
                    isRecording = false;
                    updateTalkButton();
                };
                
                recognition.onend = function() {
                    if (forceStopRecognition && fullTranscript.trim()) {
                        addMessage(fullTranscript.trim(), 'user');
                        sendToWebhook(fullTranscript.trim());
                    }
                    
                    isRecording = false;
                    forceStopRecognition = false;
                    updateTalkButton();
                };
            } else {
                showStatus('Speech recognition not supported in this browser', 'error');
            }
        }
        
        // ===== EVENT LISTENERS =====
        
        function setupEventListeners() {
            document.getElementById('speechRate').addEventListener('input', function(e) {
                document.getElementById('rateValue').textContent = e.target.value;
            });
            
            document.getElementById('webhookUrl').addEventListener('change', saveConfig);
            document.getElementById('submitWebhookUrl').addEventListener('change', saveConfig);
            document.getElementById('sheetId').addEventListener('change', saveConfig);
        }
        
        // ===== RECORDING FUNCTIONS =====
        
        function startRecording() {
            if (!recognition) {
                showStatus('Speech recognition not available', 'error');
                return;
            }
            
            if (!document.getElementById('webhookUrl').value) {
                showStatus('Please enter webhook URL first', 'error');
                return;
            }
            
            if (!currentScenario) {
                showStatus('Please select a patient scenario first', 'error');
                return;
            }
            
            fullTranscript = '';
            forceStopRecognition = false;
            
            document.getElementById('transcriptionBox').innerHTML = '<span style="color: var(--text-secondary);">Listening...</span>';
            
            isRecording = true;
            updateTalkButton();
            
            try {
                recognition.start();
                showStatus('Listening...', 'info');
            } catch (error) {
                console.error('Error starting recognition:', error);
                showStatus('Error starting recording', 'error');
                isRecording = false;
                updateTalkButton();
            }
        }
        
        function stopRecording() {
            if (isRecording && recognition) {
                console.log('Stopping recording...');
                forceStopRecognition = true;
                recognition.stop();
                showStatus('Processing...', 'info');
            }
        }
        
        function updateTalkButton() {
            const button = document.getElementById('talkButton');
            if (isRecording) {
                button.classList.add('recording');
                button.innerHTML = '🔴 Recording...';
            } else {
                button.classList.remove('recording');
                button.innerHTML = 'Push to Talk';
            }
        }
        
        // ===== GOOGLE SHEETS INTEGRATION =====
        
        async function loadSheetNames() {
            const sheetId = document.getElementById('sheetId').value;
            
            if (!sheetId) {
                showStatus('Please enter Sheet ID first', 'error');
                return;
            }
            
            showStatus('Loading sheet names...', 'info');
            
            try {
                const apiKey = 'AIzaSyDCrWAPXe6eYugvmnO1eJb7-S4QXQj3EgQ';
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}?fields=sheets.properties.title&key=${apiKey}`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const sheetNames = data.sheets.map(sheet => sheet.properties.title);
                
                populateSheetNameDropdown(sheetNames);
                showStatus(`Found ${sheetNames.length} sheets`, 'success');
                
            } catch (error) {
                console.error('Error loading sheet names:', error);
                showStatus('Could not load sheet names automatically. Enter manually below.', 'error');
                
                const select = document.getElementById('sheetName');
                select.disabled = false;
                select.innerHTML = '<option value="">Enter sheet name manually below...</option>';
            }
        }
        
        function populateSheetNameDropdown(sheetNames) {
            const select = document.getElementById('sheetName');
            select.innerHTML = '<option value="">Select a sheet...</option>';
            select.disabled = false;
            
            sheetNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
            
            select.addEventListener('change', function() {
                if (this.value) {
                    saveConfig();
                    loadSheetData();
                }
            });
        }
        
        function getSelectedSheetName() {
            const dropdown = document.getElementById('sheetName');
            return dropdown.value;
        }
        
        async function loadSheetData() {
            const sheetId = document.getElementById('sheetId').value;
            const sheetName = getSelectedSheetName();
            
            if (!sheetId || !sheetName) {
                showStatus('Please enter Sheet ID and select/enter Sheet Name', 'error');
                return;
            }
            
            showStatus(`Loading data from sheet: ${sheetName}...`, 'info');
            
            try {
                const apiKey = 'AIzaSyDCrWAPXe6eYugvmnO1eJb7-S4QXQj3EgQ';
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(sheetName)}?key=${apiKey}`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.values && data.values.length > 0) {
                    sheetData = data.values;
                    populateScenarioDropdown();
                    showStatus(`Loaded ${data.values.length - 1} scenarios from ${sheetName}`, 'success');
                } else {
                    showStatus('No data found in the selected sheet', 'error');
                }
                
            } catch (error) {
                console.error('Error loading sheet:', error);
                showStatus('Error loading sheet data. Check console for details.', 'error');
                
                if (error.message.includes('YOUR_API_KEY')) {
                    showStatus('Using demo data. Replace YOUR_API_KEY to use real data.', 'info');
                    simulateSheetData();
                }
            }
        }
        
        function simulateSheetData() {
            sheetData = [
                ['Scenario Name', 'Patient Name', 'Age', 'Gender', 'Chief Complaint', 'Medical History', 'Current Medications'],
                ['Cough Relief', 'John Smith', '45', 'Male', 'Persistent cough', 'Hypertension', 'Lisinopril 10mg'],
                ['Headache Management', 'Mary Johnson', '32', 'Female', 'Severe headaches', 'Migraines', 'None'],
                ['Arthritis Pain', 'Robert Brown', '67', 'Male', 'Joint pain', 'Arthritis, Diabetes', 'Metformin 500mg, Ibuprofen PRN'],
                ['Allergy Symptoms', 'Sarah Davis', '28', 'Female', 'Seasonal allergies', 'Asthma', 'Salbutamol inhaler'],
                ['Sleep Issues', 'Michael Wilson', '52', 'Male', 'Insomnia', 'Depression', 'Sertraline 50mg'],
                ['Skin Rash', 'Emily Taylor', '19', 'Female', 'Itchy rash on arms', 'Eczema', 'Hydrocortisone cream'],
                ['Stomach Pain', 'James Anderson', '41', 'Male', 'Abdominal discomfort', 'GERD', 'Omeprazole 20mg'],
                ['Cold Symptoms', 'Lisa Martinez', '35', 'Female', 'Runny nose and congestion', 'None', 'None'],
                ['Back Pain', 'David Thompson', '58', 'Male', 'Lower back pain', 'Previous back surgery', 'Paracetamol PRN'],
                ['Anxiety', 'Jennifer White', '26', 'Female', 'Feeling anxious', 'Generalized anxiety disorder', 'None']
            ];
            
            populateScenarioDropdown();
            showStatus('Sheet data loaded successfully', 'success');
        }
        
        function populateScenarioDropdown() {
            const select = document.getElementById('scenarioSelect');
            select.innerHTML = '<option value="">Select a scenario...</option>';
            select.disabled = false;
            
            for (let i = 1; i < sheetData.length; i++) {
                const row = sheetData[i];
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}. ${row[0]}`;
                select.appendChild(option);
            }
            
            select.removeEventListener('change', handleScenarioChange);
            select.addEventListener('change', handleScenarioChange);
        }
        
        function handleScenarioChange(e) {
            if (e.target.value) {
                selectScenario(parseInt(e.target.value));
            }
        }
        
        function selectScenario(rowIndex) {
            const headers = sheetData[0];
            const row = sheetData[rowIndex];
            
            currentScenario = {};
            headers.forEach((header, index) => {
                currentScenario[header] = row[index];
            });
            
            console.log('Selected scenario:', currentScenario);
            showStatus(`Scenario loaded: ${currentScenario['Patient Name']}`, 'success');
            
            // Update avatar based on scenario
            updateAvatarForScenario();
            
            clearChat();
            addMessage('Scenario loaded. Press and hold the talk button to start the consultation.', 'ai');
        }
        
        function updateAvatarForScenario() {
            if (!currentScenario) return;
            
            const age = parseInt(currentScenario['Age']) || 30;
            const gender = currentScenario['Gender'] || 'Male';
            
            // Map to simple avatar types (since we're using demo avatars)
            let avatarType = 'simple-female';
            
            if (gender.toLowerCase() === 'female') {
                if (age < 25) {
                    avatarType = 'simple-young';
                } else if (age > 60) {
                    avatarType = 'simple-elderly';
                } else {
                    avatarType = 'simple-female';
                }
            } else {
                if (age < 25) {
                    avatarType = 'simple-young';
                } else if (age > 60) {
                    avatarType = 'simple-elderly';
                } else {
                    avatarType = 'simple-male';
                }
            }
            
            document.getElementById('avatarSelect').value = avatarType;
            loadAvatarModel(avatarType);
            
            // Set appropriate expression based on scenario
            setTimeout(() => {
                const complaint = (currentScenario['Chief Complaint'] || '').toLowerCase();
                if (complaint.includes('pain') || complaint.includes('ache')) {
                    // For simple avatars, we'll just adjust the facial features slightly
                    adjustSimpleAvatarExpression('concerned');
                } else if (complaint.includes('happy') || complaint.includes('better')) {
                    adjustSimpleAvatarExpression('happy');
                } else if (complaint.includes('sad') || complaint.includes('depressed')) {
                    adjustSimpleAvatarExpression('sad');
                } else {
                    adjustSimpleAvatarExpression('neutral');
                }
            }, 1000);
        }
        
        function adjustSimpleAvatarExpression(expression) {
            if (!avatar) return;
            
            // Find eyebrows and mouth for simple expression changes
            const leftBrow = avatar.children.find(child => child.position.x < 0 && child.position.y > 1.7);
            const rightBrow = avatar.children.find(child => child.position.x > 0 && child.position.y > 1.7);
            const mouth = avatar.children.find(child => child.userData.type === 'mouth');
            
            // Reset to neutral
            if (leftBrow) leftBrow.rotation.z = 0;
            if (rightBrow) rightBrow.rotation.z = 0;
            if (mouth) {
                mouth.rotation.z = 0;
                mouth.scale.set(1, 1, 1);
            }
            
            // Apply expression
            switch(expression) {
                case 'happy':
                    if (mouth) {
                        mouth.rotation.z = Math.PI; // Flip to create smile
                        mouth.scale.set(1.2, 0.8, 1);
                    }
                    break;
                case 'sad':
                    if (leftBrow) leftBrow.rotation.z = -0.2;
                    if (rightBrow) rightBrow.rotation.z = 0.2;
                    if (mouth) {
                        mouth.scale.set(0.8, 1.2, 1);
                    }
                    break;
                case 'concerned':
                    if (leftBrow) leftBrow.rotation.z = -0.1;
                    if (rightBrow) rightBrow.rotation.z = 0.1;
                    if (mouth) {
                        mouth.scale.set(0.9, 0.9, 1);
                    }
                    break;
            }
            
            updateAvatarStatus(`Expression: ${expression}`, 'idle');
        }
        
        function selectRandomScenario() {
            if (sheetData.length <= 1) {
                showStatus('Please load sheet data first', 'error');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * (sheetData.length - 1)) + 1;
            document.getElementById('scenarioSelect').value = randomIndex;
            selectScenario(randomIndex);
            showStatus(`Randomly selected: ${sheetData[randomIndex][0]}`, 'success');
        }
        
        // ===== WEBHOOK COMMUNICATION =====
        
        async function sendToWebhook(message) {
            const webhookUrl = document.getElementById('webhookUrl').value;
            
            if (!webhookUrl) {
                showStatus('Webhook URL not configured', 'error');
                return;
            }
            
            addMessage('<div class="spinner"></div>', 'ai');
            
            try {
                const payload = {
                    sessionId: sessionId,
                    message: message,
                    scenario: currentScenario,
                    timestamp: new Date().toISOString(),
                    conversationHistory: conversationHistory,
                    studentInfo: {
                        sessionStartTime: new Date(parseInt(sessionId.split('_')[1])).toISOString(),
                        messageCount: conversationHistory.filter(h => h.sender === 'user').length + 1
                    }
                };
                
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    mode: 'cors',
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const responseText = await response.text();
                let data;
                
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    data = { response: responseText };
                }
                
                removeLastMessage();
                
                let aiResponse = data.response || data.message || data.text || data.output || 
                                (typeof data === 'string' ? data : null) ||
                                (Array.isArray(data) && data.length > 0 ? 
                                 (data[0].response || data[0].message || data[0]) : null);
                
                if (aiResponse) {
                    addMessage(aiResponse, 'ai');
                    // Use avatar speech instead of browser TTS
                    speakWithAvatar(aiResponse);
                } else {
                    console.error('Could not find response in data:', data);
                    showStatus('Unexpected response format from webhook', 'error');
                    addMessage('Received response but could not parse it. Check console for details.', 'ai');
                }
                
            } catch (error) {
                console.error('Webhook error:', error);
                removeLastMessage();
                
                if (error.message.includes('Failed to fetch')) {
                    showStatus('Cannot reach webhook - check URL and CORS settings', 'error');
                    addMessage('Connection failed. Make sure your n8n webhook is accessible and CORS is enabled.', 'ai');
                } else {
                    showStatus(`Error: ${error.message}`, 'error');
                    addMessage(`Error: ${error.message}`, 'ai');
                }
            }
        }
        
        // ===== SUBMIT CONVERSATION FUNCTION =====
        
        async function submitConversation() {
            const submitWebhookUrl = document.getElementById('submitWebhookUrl').value;
            
            if (!submitWebhookUrl) {
                showStatus('Submit webhook URL not configured', 'error');
                return;
            }
            
            if (conversationHistory.length === 0) {
                showStatus('No conversation to submit', 'error');
                return;
            }
            
            showStatus('Submitting conversation...', 'info');
            addMessage('📤 Submitting conversation for evaluation...', 'system');
            
            try {
                const submissionPayload = {
                    sessionId: sessionId,
                    scenario: currentScenario,
                    conversationHistory: conversationHistory,
                    submissionTime: new Date().toISOString(),
                    sessionInfo: {
                        sessionStartTime: new Date(parseInt(sessionId.split('_')[1])).toISOString(),
                        totalMessages: conversationHistory.length,
                        userMessages: conversationHistory.filter(h => h.sender === 'user').length,
                        aiMessages: conversationHistory.filter(h => h.sender === 'ai').length,
                        duration: Date.now() - parseInt(sessionId.split('_')[1])
                    },
                    metadata: {
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString(),
                        type: 'conversation_submission'
                    }
                };
                
                const response = await fetch(submitWebhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    mode: 'cors',
                    body: JSON.stringify(submissionPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
                }
                
                const responseText = await response.text();
                
                if (!responseText || responseText.trim() === '') {
                    addMessage('📋 Evaluation Complete:\n\nConversation submitted successfully, but no feedback was returned. The evaluation may be processing in the background.', 'system');
                    showStatus('✅ Conversation submitted (no feedback received)', 'success');
                    return;
                }
                
                let responseData;
                let feedbackMessage = '';
                
                try {
                    responseData = JSON.parse(responseText);
                    feedbackMessage = responseData.feedback || responseData.evaluation || 
                                    responseData.response || responseData.message || 
                                    (responseData.data && responseData.data.feedback) ||
                                    (responseData.data && responseData.data.response) ||
                                    responseData.result ||
                                    JSON.stringify(responseData, null, 2);
                } catch (parseError) {
                    if (responseText.trim().startsWith('<') && responseText.trim().includes('html')) {
                        feedbackMessage = 'Received HTML response instead of expected feedback. Check your n8n workflow output format.';
                    } else {
                        feedbackMessage = responseText.trim();
                    }
                }
                
                function formatFeedback(text) {
                    if (!text) return text;
                    
                    let formatted = text
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        .replace(/^### (.*$)/gm, '<h3 style="margin: 15px 0 10px 0; color: var(--primary-color); font-size: 1.1em;">$1</h3>')
                        .replace(/^## (.*$)/gm, '<h2 style="margin: 20px 0 10px 0; color: var(--primary-color); font-size: 1.2em;">$1</h2>')
                        .replace(/^# (.*$)/gm, '<h1 style="margin: 20px 0 15px 0; color: var(--primary-color); font-size: 1.3em;">$1</h1>')
                        .replace(/^- (.*$)/gm, '<li style="margin: 5px 0; padding-left: 5px;">$1</li>')
                        .replace(/^\d+\. (.*$)/gm, '<li style="margin: 5px 0; padding-left: 5px;">$1</li>')
                        .replace(/\n\n/g, '</p><p style="margin: 10px 0; line-height: 1.5;">')
                        .replace(/\n/g, '<br>');
                    
                    if (!formatted.includes('<p>') && !formatted.includes('<h')) {
                        formatted = `<p style="margin: 10px 0; line-height: 1.5;">${formatted}</p>`;
                    }
                    
                    if (formatted.includes('<li>')) {
                        formatted = formatted
                            .replace(/(<li>.*?<\/li>)/gs, '<ul style="margin: 10px 0; padding-left: 20px;">$1</ul>')
                            .replace(/<\/ul>\s*<ul[^>]*>/g, '');
                    }
                    
                    return formatted;
                }
                
                if (feedbackMessage) {
                    const formattedFeedback = formatFeedback(feedbackMessage);
                    addMessage(`📋 Evaluation Feedback:<br><br>${formattedFeedback}`, 'system');
                    showStatus('✅ Conversation submitted and evaluated successfully!', 'success');
                } else {
                    addMessage('📋 Evaluation Complete:\n\nConversation submitted successfully, but the feedback format was not recognized. Check console for raw response.', 'system');
                    showStatus('✅ Conversation submitted (feedback format issue)', 'success');
                }
                
            } catch (error) {
                console.error('Submit conversation error:', error);
                
                if (error.message.includes('Failed to fetch')) {
                    showStatus('Cannot reach submit webhook - check URL and CORS settings', 'error');
                    addMessage('❌ Submission failed. Make sure your n8n submit webhook is accessible and CORS is enabled.', 'system');
                } else if (error.message.includes('NetworkError')) {
                    showStatus('Network error - check n8n webhook configuration', 'error');
                    addMessage('❌ Network error. Check that your n8n webhook is running and accessible.', 'system');
                } else {
                    showStatus(`❌ Submission error: ${error.message}`, 'error');
                    addMessage(`❌ Submission failed: ${error.message}`, 'system');
                }
            }
        }
        
        // ===== EXPORT CONVERSATION FUNCTION =====
        
        function exportConversation() {
            if (conversationHistory.length === 0) {
                showStatus('No conversation to export', 'error');
                return;
            }
            
            try {
                let exportText = '';
                
                exportText += '='.repeat(60) + '\n';
                exportText += 'PHARMACY CONSULTATION TRAINING - CONVERSATION EXPORT\n';
                exportText += '='.repeat(60) + '\n\n';
                
                exportText += `Session ID: ${sessionId}\n`;
                exportText += `Export Date: ${new Date().toLocaleString()}\n`;
                exportText += `Session Start: ${new Date(parseInt(sessionId.split('_')[1])).toLocaleString()}\n\n`;
                
                if (currentScenario) {
                    exportText += 'SCENARIO DETAILS:\n';
                    exportText += '-'.repeat(20) + '\n';
                    Object.keys(currentScenario).forEach(key => {
                        if (currentScenario[key] && currentScenario[key].toString().trim() !== '') {
                            exportText += `${key}: ${currentScenario[key]}\n`;
                        }
                    });
                    exportText += '\n';
                }
                
                const userMessages = conversationHistory.filter(h => h.sender === 'user').length;
                const aiMessages = conversationHistory.filter(h => h.sender === 'ai').length;
                const sessionDuration = Date.now() - parseInt(sessionId.split('_')[1]);
                const durationMinutes = Math.floor(sessionDuration / 60000);
                const durationSeconds = Math.floor((sessionDuration % 60000) / 1000);
                
                exportText += 'CONVERSATION STATISTICS:\n';
                exportText += '-'.repeat(25) + '\n';
                exportText += `Total Messages: ${conversationHistory.length}\n`;
                exportText += `Student Messages: ${userMessages}\n`;
                exportText += `AI Patient Messages: ${aiMessages}\n`;
                exportText += `Session Duration: ${durationMinutes}m ${durationSeconds}s\n\n`;
                
                exportText += 'FULL CONVERSATION:\n';
                exportText += '-'.repeat(20) + '\n\n';
                
                const chatContainer = document.getElementById('chatContainer');
                const messageElements = chatContainer.getElementsByClassName('message');
                
                for (let i = 0; i < messageElements.length; i++) {
                    const messageElement = messageElements[i];
                    const messageClass = messageElement.className;
                    
                    let speaker = 'UNKNOWN';
                    if (messageClass.includes('user')) {
                        speaker = 'STUDENT';
                    } else if (messageClass.includes('ai')) {
                        speaker = 'AI PATIENT';
                    } else if (messageClass.includes('system')) {
                        speaker = 'SYSTEM';
                    }
                    
                    let messageContent = messageElement.innerHTML
                        .replace(/<br\s*\/?>/g, '\n')
                        .replace(/<\/p><p[^>]*>/g, '\n\n')
                        .replace(/<p[^>]*>/g, '')
                        .replace(/<\/p>/g, '')
                        .replace(/<h[1-3][^>]*>/g, '\n')
                        .replace(/<\/h[1-3]>/g, ':\n')
                        .replace(/<strong>/g, '**')
                        .replace(/<\/strong>/g, '**')
                        .replace(/<em>/g, '*')
                        .replace(/<\/em>/g, '*')
                        .replace(/<ul[^>]*>/g, '\n')
                        .replace(/<\/ul>/g, '')
                        .replace(/<li[^>]*>/g, '  • ')
                        .replace(/<\/li>/g, '\n')
                        .replace(/<[^>]*>/g, '')
                        .replace(/&nbsp;/g, ' ')
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"')
                        .replace(/\n\s*\n\s*\n/g, '\n\n')
                        .trim();
                    
                    if (!messageContent || messageContent.includes('spinner')) {
                        continue;
                    }
                    
                    exportText += `${speaker}:\n`;
                    
                    const lines = messageContent.split('\n');
                    lines.forEach(line => {
                        if (line.trim()) {
                            exportText += `  ${line.trim()}\n`;
                        } else {
                            exportText += '\n';
                        }
                    });
                    
                    exportText += '\n';
                }
                
                exportText += '='.repeat(60) + '\n';
                exportText += 'End of Conversation Export\n';
                exportText += `Generated by Pharmacy Training System v2.0 (with Avatar)\n`;
                exportText += '='.repeat(60) + '\n';
                
                const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
                const url = window.URL.createObjectURL(blob);
                
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
                const scenarioName = currentScenario && currentScenario['Scenario Name'] 
                    ? currentScenario['Scenario Name'].replace(/[^a-zA-Z0-9]/g, '_') 
                    : 'Unknown_Scenario';
                
                downloadLink.download = `Pharmacy_Training_Avatar_${scenarioName}_${dateStr}_${timeStr}.txt`;
                
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                window.URL.revokeObjectURL(url);
                
                showStatus('✅ Conversation exported successfully!', 'success');
                
            } catch (error) {
                console.error('Export error:', error);
                showStatus(`❌ Export failed: ${error.message}`, 'error');
            }
        }
        
        // ===== CHAT MANAGEMENT =====
        
        function addMessage(text, sender) {
            const chatContainer = document.getElementById('chatContainer');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            messageDiv.innerHTML = text;
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            if (!text.includes('spinner') && sender !== 'system') {
                conversationHistory.push({
                    sender: sender,
                    message: text,
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        function removeLastMessage() {
            const chatContainer = document.getElementById('chatContainer');
            const messages = chatContainer.getElementsByClassName('message');
            if (messages.length > 0) {
                messages[messages.length - 1].remove();
            }
        }
        
        function clearChat() {
            document.getElementById('chatContainer').innerHTML = '';
            conversationHistory = [];
            
            // Stop any ongoing speech
            speechSynthesis.cancel();
            stopAvatarSpeaking();
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
        
        function saveConfig() {
            const config = {
                webhookUrl: document.getElementById('webhookUrl').value,
                submitWebhookUrl: document.getElementById('submitWebhookUrl').value,
                sheetId: document.getElementById('sheetId').value,
                sheetName: getSelectedSheetName()
            };
            localStorage.setItem('pharmacyChatConfig', JSON.stringify(config));
        }
        
        function loadSavedConfig() {
            const saved = localStorage.getItem('pharmacyChatConfig');
            if (saved) {
                const config = JSON.parse(saved);
                document.getElementById('webhookUrl').value = config.webhookUrl || '';
                document.getElementById('submitWebhookUrl').value = config.submitWebhookUrl || '';
                document.getElementById('sheetId').value = config.sheetId || '';
                
                const sheetNameDropdown = document.getElementById('sheetName');
                if (config.sheetName) {
                    if (sheetNameDropdown.options.length > 1) {
                        sheetNameDropdown.value = config.sheetName;
                    }
                }
            }
        }
    </script>
</body>
</html>
